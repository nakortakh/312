# Push Notifications

## Что такое push-уведомления?
Push-уведомление – это короткие сообщения, всплывающие на экране компьютера или мобильного телефона с различной информацией поверх любых открытых окон. (`"PushManager" in window`)

Notification (уведомление) - это тоже короткие всплывающие сообщения, но инициализированное из кода открытой страницы. (`"Notification" in window`)

Push-уведомление и Notification — это две отдельные, но взаимодополняющие технологии.

![Пример уведомления](https://web.dev/static/articles/push-notifications-overview/image/examples-notifications-940d01bcab836_856.png?hl=ru)

## Как это работает?
Три ключевых шага для реализации push-уведомлений:
1. Добавление логики на стороне клиента для подписки пользователя на отправку сообщений.
2. Вызов API из вашей серверной части/приложения, который отправляет push-уведомление на устройство пользователя.
3. Файл service worker'а, который получит событие «push», когда push-уведомление поступит на устройство.

![Более подробная схема](https://pushpad.xyz/assets/web_push_sequence_diagram-126e9c554725391202b650ca369c5e1860e6200096fdc7f18718255d924610e4.png)

**Шаг 1: Клиентская часть**
Необходимо получить разрешение от пользователя на отправку ему push-уведомление, для этого вызываем метод `Notification.requestPermission()` , для сафари - `window.safari.pushNotification.requestPermission()`

![Пример запроса](https://pushpad.xyz/blog-images/web-push-browser-prompt.png)

Регистрируем сервис-воркер, подписываемся на уведомления.
```
const publicVapidKey = "BD-xkyjqdwCWjStuK2b7MXm5XZI7FgFoYLwvqe8i1gxTsRCIlpXM9i3zC3DhVn95RIrffNnR4hmqo7ZYmkyxtAo";

const register = await navigator.serviceWorker.register('./service-worker.js', {
    scope: '/'
});

const pushSubscription = await register.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: publicVapidKey,
});
```
Далее нужно будет отправить данные pushSubscription на свой бэкэнд/сервер. На своем сервере вы сохраните эту подписку в базе данных и будете использовать ее для отправки push-сообщения этому пользователю.

PushSubscription содержит всю информацию, необходимую для отправки push-сообщения этому пользователю. Вы можете думать об этом как об идентификаторе устройства этого пользователя.
Пример PushSubscription.
```
{
  "endpoint": "https://random-push-service.com/unique-id-1234/",
  "keys": {
    "p256dh" : "BNcRdreALRFXTkOOUHK1EtK2wtaz5Ry4YfYCA_0QTpQtUbVlUls0VJXg7A8u-Ts1XbjhazAkj7I99e8QcYP7DkM=",
    "auth"   : "tBHItJI5svbpez7KI4CCXg=="
  }
}
```
Перед подпиской пользователя вам необходимо сгенерировать набор «ключей сервера приложений».

Ключи сервера приложений, также известные как ключи VAPID, уникальны для вашего сервера. Они позволяют службе push-уведомлений узнать, какой сервер приложений подписался на пользователя, и гарантировать, что именно тот же сервер инициирует отправку push-сообщений этому пользователю. 

**Шаг 2. Отправляем push-уведомление**
Если вы хотите отправить push-сообщение своим пользователям, вам необходимо выполнить API-вызов push службы.
```
const webpush = require('web-push');
...
// pushSubscription был получен c frontend'а
const payload = JSON.stringify({ title: "Hello World!", body: "This is your first push notification!" });
webpush.sendNotification(pushSubscription, payload);
```
web-push - библиотека (java, JS, python, C#, PHP), которая скрывает детали реализации web push протокола.

**Шаг 3. Отправляем событие на устройство пользователя.**
После того как мы отправили push-уведомление, служба push-уведомлений будет хранить ваше сообщение на своем сервере до тех пор, пока не произойдет одно из следующих событий:
- Устройство подключается к сети, и служба push доставляет сообщение.
- Срок действия сообщения истекает. В этом случае служба push-уведомлений удаляет сообщение из своей очереди и оно никогда не будет доставлено.

Когда служба push-уведомлений доставляет сообщение, браузер получит сообщение, расшифрует все данные и отправит событие push уведомления в ваш сервис-воркер.
```
// service-worker.js

self.addEventListener('push', function(e) {
    const data = e.data.json();
    self.registration.showNotification(
        data.title,
        {
            body: data.body,
        }
    );
})
```

## Что такое Web Push Protocol?
Это стандарт IETF, который определяет, как вы выполняете вызов API к службе push-уведомлений. 

Когда мы подписываем пользователя, мы передаем applicationServerKey. Этот ключ передается службе push-уведомлений и используется для проверки того, что приложение, подписавшееся на пользователя, также является приложением, которое запускает push-сообщения.

Данные, которые вы отправляете с push-сообщением, должны быть зашифрованы, чтобы службы push-уведомлений не могли их просмотреть. Шифрование полезной нагрузки осуществляется с помощью данных, которые были получены от браузера в объекте PushSubscription. Подробнее можно почитать [тут](https://web.dev/articles/push-notifications-web-push-protocol?hl=ru#inputs).

## Что такое GCM?
При поиске туториалов или справочной информации о push-уведомлениях и Notifications, попадаются источники про GCM, которые сбивают с толку, особенно в самом начале изучения данной темы. Дело в том, что Chrome впервые реализовал веб-push в декабре 2014 года, Chrome использовал Google Cloud Messaging (GCM) для отправки push-сообщений с сервера в браузер. Это не был "настоящий" Web Push.
Вот некоторые особенности:
- GCM требовал, чтобы разработчики создали учетные записи в консоли разработчиков Google.
- Chrome и GCM требовался специальный идентификатор отправителя, который необходимо было передать веб-приложению, чтобы была возможность правильно настроить обмен сообщениями.
- Серверы GCM принимали специальный запрос API, который не был веб-стандартом.

В июле 2016 года появилась новая функция в Web Push — ключи сервера приложений (или VAPID, как известно из спецификации). Когда Chrome добавил поддержку этого нового API, он использовал Firebase Cloud Messaging (FCM) вместо GCM в качестве службы обмена сообщениями.
Это важно по нескольким причинам:
- Не требуется какая-либо настройка проекта с помощью Google или Firebase. 
- FCM поддерживает протокол Web Push, который будут поддерживать все службы веб-push. Это означает, что независимо от того, какую службу push-уведомлений использует браузер, вы просто делаете один и тот же запрос, и он отправляет сообщение.

Стоит отметить, что каждый браузер использует свою службу доставки уведомлений:
- Chrome использует Firebase Cloud Messaging (FCM) (https://fcm.googleapis.com/fcm/send/ekHVEOvQjho:APA91bHOoW3......EaUGsN92Q8)
- Safari использует Apple Push Notification service (APNs) (https://api.push.apple.com/...)
- Firefox использует серверы MDN (https://updates.push.services.mozilla.com/wpush/v2/gAAAAABmKKWsuEX......dR3)
- Edge использует Windows Push Notification Services (WNS) (https://wns2-db5p.notify.windows.com/w/?token=BQYAA......gOW)

## Почему Firebase?
Firebase Cloud Messaging (FCM) — это кроссплатформенное решение для обмена сообщениями, которое позволяет надежно отправлять сообщения бесплатно.

Firebase Cloud Messaging JS SDK выполняет несколько скрытых трюков, чтобы упростить реализацию веб-push:
- Вместо того, чтобы беспокоиться о PushSubscription и его различных полях, вам нужно беспокоиться только о токене FCM (строке).
- Используя токены для каждого пользователя, вы можете использовать собственный API FCM для запуска push-сообщений. Этот API не требует шифрования полезных данных. Вы можете отправить полезную нагрузку в виде простого текста в теле запроса POST.
- Собственный API FCM поддерживает пользовательские функции, например темы FCM (он также работает в Web, хотя плохо документирован).
- FCM поддерживает Android, iOS и Web.

Если рассматриваеть Web Push просто как службу push-уведомлений, то вы можете считать Firebase Messaging SDK библиотекой для упрощения реализации веб-push.

Некоторые ключевые возможности, которые дает FCM:
- Универсальный таргетинг сообщений: отправка сообщений на отдельные устройства, на группы устройств или на устройства, подписанные на определенные темы.
- Просмотр статистики.

## Safari
Для отправки push-уведомлений на устройства с Safari ниже версии 16.4 вам необходимо иметь аккаунт разработчика Apple.

Приблизительный список шагов для реализации push-уведомлений:
1. Регистрируем Website Push ID через аккаунт разработчика.
2. Запрашиваем сертификат в Связке ключей на MacOS.
3. Генерируем сертификат через аккаунт разработчика.
4. Закидываем сертификаты на сайт.
5. Добавляем в наше приложение manifest.json, signature, website.json чтобы браузер разрешил получать push-уведомления.
6. Получаем разрешение на push-уведомления.

Некоторые ключевые моменты:
- *Для отображения push-уведомлений в браузере Safari не требуется Service Worker.*
- *С версии Safari 16.4, появилась возможность получать уведомления в PWA*
- *Push-уведомления доступны только для PWA*
- *Попап с запросом на получение уведомлений должно быть инициировано пользовательским событием, например нажатием кнопки*

## Мобильные Push-уведомления
Веб-push-уведомления не могут быть отправлены пользователям, если их браузер не открыт.Мобильные push-уведомления отправляются непосредственно в операционную систему устройства (например, iOS, Android).

Android отправляет через службу push-уведомлений Google Firebase Cloud Messaging (FCM), iOS - Apple Push Notification service (APNs), Huawei - Huawei Push Kit.

#### iOS
По типу отправки push-уведомления делятся на локальные (Local Notifications) и удаленные (Remote Push Notifications). Для обоих типов уведомлений необходимо запросить у пользователя разрешение на их отправку.

Локальные уведомления могут быть активированы только датой, временем и местом.
Чтобы обновить локальные уведомления (добавить новую логику, задать новые параметры, изменить дизайн или содержание), разработчик должен выпустить новую версию приложения. Поскольку удаленные уведомления отправляются через внешний сервер, у вас есть возможность вносить изменения в свои кампании без выпуска новой версии приложения.

Удаленные пуш-уведомления также имеют несколько модификаций - Предварительные уведомления (Provisional Messages) и Silent Push Notifications.

#### Android
~~Пользователи Android автоматически дают разрешение на отправку уведомлений при загрузке приложения.~~
Также как и в iOS пуши на Android делятся на два типа по способу отправки - локальные и удаленные.

## Поезная инфа из различных источников
#### [vk tech](https://www.youtube.com/watch?v=l8EWDilTMr4)
- Данные которые бэк хранит о девайсе: platform (enum), app_id, token, device_id, update_time.
- Если устройство "протухло", то push-провайдер возвращает соответствующий ответ - нужно правильно его обработать.
- Если устройство долго лежит в шкафу, то слать на него push-уведомление не целесообразно - начинаем смотреть на update_time устройства.
- Бывают ситуации, когда пользователь делает logout на своем устройстве и это происходит с ошибками. Чтобы не слать push-уведомление на это устройство, при создании новой подписки нужно сравнивать токены с существующими токенами других пользователей. Если такие пользователи находятся, то удаляем у них эти устройства.
- Служебные поля (platform, app_id, push_token), содержание уведомления (type, title, text, subtitle) и данные уведомления (id, group_id, url, images, stat).
По id можно сделать схлопывание уведомлений, например, после редактирования сообщения в соцсетях отправляется новое push-уведомление с тем же id сообщения. Новое уведомление заменяет предыдущее.
Если мы хотим удалить push-уведомление, то мы отправляем другое push-уведомление в котором есть команда на удаление, которое обрабатыфвает приложение: находит push-уведомление по id (похоже только на мобильных). В браузерах можно реализовать подобное поведение, но только через активные вкладки. [тык](https://translated.turbopages.org/proxy_u/en-ru.ru.c131a29e-6641c1c5-7838e215-74722d776562/https/stackoverflow.com/questions/49488408/remove-a-web-push-notification)
- Сбор статистики с push'ей: возвращаем на сервер поле stat ("time_send=123&log_id=345...") - собираем все действия с push'ами (получение push'а, клик по push'у, скрытие  и т д). Можно измерить время доставки push'а.
- Мониторинг push'ей: количество отправленных push'ей, среднее время обработки push'а, состояние серверов. Логируем таймауты к push-провайдерам.

#### [тоже vk tech](https://habr.com/ru/companies/oleg-bunin/articles/728516/)
- RuStore собирает все пуши на девайсе и рассылает их конкретным приложениям внутри девайса. Из этого следует логичное ограничение — для юзеров, у которых нет RuStore на девайсе, не будут ходить пуши. Но зато мы можем получать все пуши ровно через один WebSocket, и дальше рассылать их внутри девайса, а не держать отдельный WebSocket для каждого приложения, что могло бы, например, потреблять аккумулятор у юзера.

**Полезные ссылки:**
- [Web Push Book](https://web-push-book.gauntface.com/)
- [Web Dev Notifications](https://web.dev/explore/notifications?hl=ru)
- [Apple Developer PushNotifications](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/NotificationProgrammingGuideForWebsites/PushNotifications/PushNotifications.html)
- [Mobile Push Notifications](https://tracker.my.com/blog/222/podrobnij-gajd-po-mobilnim-push-uvedomleniyam?lang=ru)
- [Sending web push notifications in Safari](https://developer.apple.com/documentation/UserNotifications/sending-web-push-notifications-in-web-apps-and-browsers)
